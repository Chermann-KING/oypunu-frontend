import { Injectable } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, BehaviorSubject } from 'rxjs';
import { map } from 'rxjs/operators';
import * as io from 'socket.io-client';
import { environment } from '../../../environments/environment';

export interface Activity {
  id: string;
  userId: string;
  username: string;
  activityType: string;
  entityType: string;
  entityId: string;
  metadata: {
    wordName?: string;
    languageCode?: string;
    languageName?: string;
    languageFlag?: string;
    categoryName?: string;
    translatedWord?: string;
    targetLanguageCode?: string;
    synonymsCount?: number;
    postTitle?: string;
    communityName?: string;
    voteType?: 'like' | 'dislike' | 'helpful' | 'accurate';
  };
  languageRegion?: string;
  userRegion?: string;
  createdAt: string;
  timeAgo: string;
  message: string;
  flag: string;
  isPublic: boolean;
  // Champs d'affichage enrichis
  displayLabel?: string;
  displayIcon?: string;
  typeColor?: string;
}

@Injectable({
  providedIn: 'root',
})
export class ActivityService {
  private socket: any;
  private activitiesSubject = new BehaviorSubject<Activity[]>([]);
  private connectedClientsSubject = new BehaviorSubject<number>(0);

  public activities$ = this.activitiesSubject.asObservable();
  public connectedClients$ = this.connectedClientsSubject.asObservable();

  constructor(private http: HttpClient) {
    this.initializeWebSocket();
  }

  private initializeWebSocket(): void {
    // Se connecter au namespace des activit√©s
    this.socket = io.connect(`${environment.websocketUrl}/activities`, {
      autoConnect: true,
      reconnection: true,
      reconnectionDelay: 1000,
      reconnectionAttempts: 5,
      transports: ['websocket', 'polling'],
    });

    // √âcouter les nouvelles activit√©s
    this.socket.on(
      'activities:new',
      (data: { activity: Activity; timestamp: string }) => {
        const enriched = this.enrichActivity(data.activity);
        console.log('üî¥ Nouvelle activit√© re√ßue:', enriched);
        this.addNewActivity(enriched);
      }
    );

    // √âcouter les activit√©s r√©centes
    this.socket.on('activities:recent', (activities: Activity[]) => {
      const enriched = activities.map((a) => this.enrichActivity(a));
      console.log('üìã Activit√©s r√©centes re√ßues:', enriched.length);
      this.activitiesSubject.next(enriched);
    });

    // √âcouter le nombre de clients connect√©s
    this.socket.on('activities:clients_count', (count: number) => {
      this.connectedClientsSubject.next(count);
    });

    // √âcouter les erreurs
    this.socket.on('activities:error', (error: any) => {
      console.error('‚ùå Erreur WebSocket activit√©s:', error);
    });

    // √âcouter les √©v√©nements de connexion/d√©connexion
    this.socket.on('connect', () => {
      console.log('‚úÖ WebSocket activit√©s connect√©');
      // Demander les activit√©s r√©centes d√®s la connexion
      setTimeout(() => {
        this.requestRecentActivities(10, true);
      }, 100);
    });

    this.socket.on('disconnect', () => {
      console.log('‚ùå WebSocket activit√©s d√©connect√©');
    });

    // Se connecter automatiquement
    this.connect();
  }

  connect(): void {
    if (!this.socket.connected) {
      console.log('üîå Connexion au WebSocket des activit√©s...');
      this.socket.connect();
    }
  }

  disconnect(): void {
    if (this.socket.connected) {
      console.log('üîå D√©connexion du WebSocket des activit√©s...');
      this.socket.disconnect();
    }
  }

  // Ajouter une nouvelle activit√© au d√©but de la liste
  private addNewActivity(newActivity: Activity): void {
    const currentActivities = this.activitiesSubject.value;
    const updatedActivities = [newActivity, ...currentActivities.slice(0, 9)]; // Garder les 10 plus r√©centes
    this.activitiesSubject.next(updatedActivities);
  }

  // Demander les activit√©s r√©centes
  requestRecentActivities(
    limit: number = 10,
    prioritizeAfrican: boolean = true
  ): void {
    this.socket.emit('activities:request_recent', { limit, prioritizeAfrican });
  }

  // Demander les activit√©s par type
  requestActivitiesByType(activityType: string, limit: number = 5): void {
    this.socket.emit('activities:request_by_type', { activityType, limit });
  }

  // API REST pour les activit√©s (fallback si WebSocket n'est pas disponible)
  getRecentActivities(
    limit: number = 10,
    prioritizeAfrican: boolean = true
  ): Observable<{
    activities: Activity[];
    count: number;
    timestamp: string;
  }> {
    return this.http
      .get<{
        activities: Activity[];
        count: number;
        timestamp: string;
      }>(
        `${environment.apiUrl}/activities/recent?limit=${limit}&prioritizeAfrican=${prioritizeAfrican}`
      )
      .pipe(
        map((res) => ({
          ...res,
          activities: (res.activities || []).map((a) => this.enrichActivity(a)),
        }))
      );
  }

  getActivitiesByType(
    activityType: string,
    limit: number = 5
  ): Observable<{
    activityType: string;
    activities: Activity[];
    count: number;
    timestamp: string;
  }> {
    return this.http
      .get<{
        activityType: string;
        activities: Activity[];
        count: number;
        timestamp: string;
      }>(
        `${environment.apiUrl}/activities/by-type?type=${activityType}&limit=${limit}`
      )
      .pipe(
        map((res) => ({
          ...res,
          activities: (res.activities || []).map((a) => this.enrichActivity(a)),
        }))
      );
  }

  getActivityStats(): Observable<{
    stats: {
      totalRecentActivities: number;
      wordCreatedCount: number;
      translationCount: number;
      connectedClients: number;
    };
    recentActivities: Activity[];
    timestamp: string;
  }> {
    return this.http.get<any>(`${environment.apiUrl}/activities/stats`);
  }

  // M√©thodes de test
  createTestActivity(testData: {
    activityType?: string;
    wordName?: string;
    languageCode?: string;
    username?: string;
  }): Observable<any> {
    return this.http.post(`${environment.apiUrl}/activities/test`, testData);
  }

  testBroadcast(): Observable<any> {
    return this.http.post(
      `${environment.apiUrl}/activities/test-broadcast`,
      {}
    );
  }

  // Utilitaires
  isConnected(): boolean {
    return this.socket && this.socket.connected;
  }

  getConnectionStatus(): string {
    if (!this.socket) return 'non-initialis√©';
    return this.socket.connected ? 'connect√©' : 'd√©connect√©';
  }

  // Formater le type d'activit√© pour l'affichage
  formatActivityType(activityType: string): string {
    const typeMap: { [key: string]: string } = {
      word_created: 'Mot ajout√©',
      translation_added: 'Traduction ajout√©e',
      synonym_added: 'Synonymes ajout√©s',
      word_approved: 'Mot approuv√©',
      word_verified: 'Traduction v√©rifi√©e',
      community_post_created: 'Publication cr√©√©e',
      comment_added: 'Commentaire ajout√©',
      user_registered: 'Inscription',
      user_logged_in: 'Connexion',
      user_logged_out: 'D√©connexion',
      community_joined: 'Communaut√© rejointe',
      community_created: 'Communaut√© cr√©√©e',
      // Audio & favoris
      audio_added: 'Audio ajout√©',
      audio_deleted: 'Audio supprim√©',
      audio_bulk_updated: 'Audios mis √† jour',
      word_favorited: 'Ajout√© aux favoris',
      word_unfavorited: 'Retir√© des favoris',
      vote_action: 'Vote',
      word_updated: 'Mot mis √† jour',
      word_deleted: 'Mot supprim√©',
      achievement_unlocked: 'Succ√®s d√©bloqu√©',
      xp_gained: 'XP gagn√©',
      // Contenu
      language_created: 'Langue cr√©√©e',
      category_created: 'Cat√©gorie cr√©√©e',
    };

    return typeMap[activityType] || activityType;
  }

  // Obtenir la couleur du type d'activit√©
  getActivityTypeColor(activityType: string): string {
    const colorMap: { [key: string]: string } = {
      word_created: 'text-green-400',
      translation_added: 'text-blue-400',
      synonym_added: 'text-yellow-400',
      word_approved: 'text-purple-400',
      word_verified: 'text-emerald-400',
      community_post_created: 'text-orange-400',
      comment_added: 'text-cyan-400',
      user_registered: 'text-pink-400',
      user_logged_in: 'text-indigo-400',
      user_logged_out: 'text-indigo-300',
      community_joined: 'text-teal-400',
      community_created: 'text-amber-400',
      audio_added: 'text-sky-400',
      audio_deleted: 'text-red-400',
      audio_bulk_updated: 'text-sky-300',
      word_favorited: 'text-yellow-300',
      word_unfavorited: 'text-yellow-500',
      vote_action: 'text-blue-300',
      word_updated: 'text-orange-300',
      word_deleted: 'text-red-500',
      achievement_unlocked: 'text-fuchsia-400',
      xp_gained: 'text-lime-400',
      language_created: 'text-green-300',
      category_created: 'text-emerald-300',
    };

    return colorMap[activityType] || 'text-gray-400';
  }

  // Nettoyer les ressources
  ngOnDestroy(): void {
    if (this.socket) {
      this.socket.disconnect();
    }
  }

  // ===== Enrichissement d'activit√© pour affichage =====
  private enrichActivity(activity: Activity): Activity {
    const a = { ...activity } as Activity;

    // Ic√¥ne par type
    const iconMap: Record<string, string> = {
      word_created: 'üìó',
      translation_added: 'üî§',
      synonym_added: 'üß©',
      word_approved: '‚úÖ',
      word_verified: 'üõ°Ô∏è',
      community_post_created: 'üó£Ô∏è',
      comment_added: 'üí¨',
      user_registered: 'üìù',
      user_logged_in: 'üîê',
      user_logged_out: 'ÔøΩ',
      community_joined: 'üë•',
      community_created: 'üåê',
      audio_added: 'üéß',
      audio_deleted: 'üóëÔ∏è',
      audio_bulk_updated: 'üéõÔ∏è',
      word_favorited: '‚≠ê',
      word_unfavorited: '‚òÜ',
      vote_action: 'üëç',
      word_updated: '‚úèÔ∏è',
      word_deleted: 'üóëÔ∏è',
      xp_gained: 'üèÖ',
      achievement_unlocked: 'üéâ',
      language_created: 'üà≥',
      category_created: 'üè∑Ô∏è',
    };

    const type = a.activityType;
    const label = this.formatActivityType(type);
    const color = this.getActivityTypeColor(type);
    const username = a.username || 'Utilisateur';
    const m = a.metadata || {};

    // Drapeau/langue
    a.flag =
      a.flag ||
      m.languageFlag ||
      this.languageCodeToFlag(m.languageCode) ||
      'üåê';

    // Construire un message si absent
    if (!a.message || a.message.trim().length === 0) {
      a.message = this.buildMessage(type, m);
      if (!a.message) {
        // Fallback g√©n√©rique
        a.message = `a effectu√© une action: ${label.toLowerCase()}`;
      }
    }

    a.displayIcon = iconMap[type] || '‚ö°';
    a.displayLabel = label;
    a.typeColor = color;

    // timeAgo fallback si manquant
    if (!a.timeAgo && a.createdAt) {
      a.timeAgo = this.timeAgoFrom(new Date(a.createdAt));
    }

    // Assurer un username non vide c√¥t√© affichage
    a.username = username;
    return a;
  }

  private buildMessage(type: string, m: Activity['metadata']): string {
    switch (type) {
      case 'word_created':
        return m.wordName
          ? `a ajout√© le mot ¬´ ${m.wordName} ¬ª`
          : 'a ajout√© un mot';
      case 'translation_added': {
        const target = m.targetLanguageCode
          ? m.targetLanguageCode.toUpperCase()
          : 'une autre langue';
        return m.wordName
          ? `a traduit ¬´ ${m.wordName} ¬ª vers ${target}`
          : `a ajout√© une traduction vers ${target}`;
      }
      case 'audio_added':
        return m.wordName
          ? `a ajout√© un audio √† ¬´ ${m.wordName} ¬ª`
          : 'a ajout√© un audio';
      case 'audio_deleted':
        return m.wordName
          ? `a supprim√© un audio de ¬´ ${m.wordName} ¬ª`
          : 'a supprim√© un audio';
      case 'word_favorited':
        return m.wordName
          ? `a ajout√© ¬´ ${m.wordName} ¬ª aux favoris`
          : 'a ajout√© un mot aux favoris';
      case 'word_unfavorited':
        return m.wordName
          ? `a retir√© ¬´ ${m.wordName} ¬ª des favoris`
          : 'a retir√© un favori';
      case 'vote_action': {
        const vt = m.voteType || 'like';
        const verb =
          vt === 'dislike'
            ? 'a d√©sapprouv√©'
            : vt === 'helpful'
            ? 'a jug√© utile'
            : vt === 'accurate'
            ? 'a valid√©'
            : 'a aim√©';
        return m.wordName ? `${verb} ¬´ ${m.wordName} ¬ª` : `${verb} un contenu`;
      }
      case 'word_updated':
        return m.wordName
          ? `a mis √† jour ¬´ ${m.wordName} ¬ª`
          : 'a mis √† jour un mot';
      case 'word_deleted':
        return m.wordName
          ? `a supprim√© ¬´ ${m.wordName} ¬ª`
          : 'a supprim√© un mot';
      case 'achievement_unlocked':
        return 'a d√©bloqu√© un succ√®s';
      case 'xp_gained':
        return 'a gagn√© de l‚ÄôXP';
      case 'user_logged_in':
        return "s'est connect√©";
      case 'user_logged_out':
        return "s'est d√©connect√©";
      case 'user_registered':
        return "s'est inscrit";
      case 'community_post_created':
      case 'community_post':
        return m.postTitle
          ? `a post√© ¬´ ${m.postTitle} ¬ª`
          : 'a post√© dans la communaut√©';
      case 'community_created':
        return m.communityName
          ? `a cr√©√© la communaut√© ¬´ ${m.communityName} ¬ª`
          : 'a cr√©√© une communaut√©';
      case 'language_created':
        return m.languageName
          ? `a ajout√© la langue ¬´ ${m.languageName} ¬ª`
          : 'a ajout√© une langue';
      case 'category_created':
        return m.categoryName
          ? `a cr√©√© la cat√©gorie ¬´ ${m.categoryName} ¬ª`
          : 'a cr√©√© une cat√©gorie';
      default:
        return '';
    }
  }

  private languageCodeToFlag(code?: string): string | undefined {
    if (!code) return undefined;
    const map: Record<string, string> = {
      fr: 'üá´üá∑',
      en: 'üá¨üáß',
      en_us: 'üá∫üá∏',
      es: 'üá™üá∏',
      de: 'üá©üá™',
      it: 'üáÆüáπ',
      pt: 'üáµüáπ',
      pt_br: 'üáßüá∑',
      zu: 'üáøüá¶',
      xh: 'üáøüá¶',
      st: 'üáøüá¶',
      tw: 'üá¨üá≠',
      ak: 'üá¨üá≠',
      yo: 'üá≥üá¨',
      ig: 'üá≥üá¨',
      ha: 'üá≥üá¨',
      sw: 'üá∞üá™',
      am: 'üá™üáπ',
      ar: 'üá≤üá¶',
    };
    const key = code.toLowerCase();
    return map[key] || undefined;
  }

  private timeAgoFrom(date: Date): string {
    const seconds = Math.floor((Date.now() - date.getTime()) / 1000);
    const intervals: [number, string][] = [
      [60, 's'],
      [60, 'min'],
      [24, 'h'],
      [7, 'j'],
      [4.345, 'sem'],
      [12, 'mois'],
      [Number.MAX_SAFE_INTEGER, 'an'],
    ];
    let count = seconds;
    let unit = 's';
    for (const [step, u] of intervals) {
      if (count < step) {
        unit = u;
        break;
      }
      count = Math.floor(count / step);
      unit = u;
    }
    return `il y a ${count} ${unit}`;
  }
}
