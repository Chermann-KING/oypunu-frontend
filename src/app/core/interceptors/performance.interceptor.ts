import { Injectable } from '@angular/core';\nimport { HttpInterceptor, HttpRequest, HttpHandler, HttpEvent, HttpResponse, HttpErrorResponse } from '@angular/common/http';\nimport { Observable } from 'rxjs';\nimport { tap, finalize } from 'rxjs/operators';\nimport { PerformanceService } from '../../shared/services/performance.service';\nimport { ToastService } from '../../shared/services/toast.service';\n\n@Injectable()\nexport class PerformanceInterceptor implements HttpInterceptor {\n  private pendingRequests = new Map<string, number>();\n  private slowRequestThreshold = 3000; // 3 secondes\n  private retryAttempts = new Map<string, number>();\n\n  constructor(\n    private performanceService: PerformanceService,\n    private toastService: ToastService\n  ) {}\n\n  intercept(req: HttpRequest<any>, next: HttpHandler): Observable<HttpEvent<any>> {\n    const startTime = Date.now();\n    const requestId = this.generateRequestId(req);\n    \n    // Enregistrer le début de la requête\n    this.pendingRequests.set(requestId, startTime);\n\n    // Vérifier si c'est un retry\n    const currentAttempts = this.retryAttempts.get(requestId) || 0;\n    if (currentAttempts > 0) {\n      // Ajouter un header pour identifier les retentatives\n      req = req.clone({\n        setHeaders: {\n          'X-Retry-Attempt': currentAttempts.toString()\n        }\n      });\n    }\n\n    return next.handle(req).pipe(\n      tap({\n        next: (event: HttpEvent<any>) => {\n          if (event instanceof HttpResponse) {\n            this.handleSuccess(requestId, startTime, req, event);\n          }\n        },\n        error: (error: HttpErrorResponse) => {\n          this.handleError(requestId, startTime, req, error);\n        }\n      }),\n      finalize(() => {\n        // Nettoyer les maps\n        this.pendingRequests.delete(requestId);\n        \n        // Ne supprimer les retry attempts qu'après un délai pour permettre les retentatives\n        setTimeout(() => {\n          this.retryAttempts.delete(requestId);\n        }, 30000);\n      })\n    );\n  }\n\n  /**\n   * Gère les réponses réussies\n   */\n  private handleSuccess(\n    requestId: string, \n    startTime: number, \n    req: HttpRequest<any>, \n    response: HttpResponse<any>\n  ): void {\n    const endTime = Date.now();\n    const responseTime = endTime - startTime;\n\n    // Enregistrer les métriques\n    this.performanceService.recordApiCall(responseTime);\n    this.performanceService.recordUserAction();\n\n    // Alerter si la requête est trop lente\n    if (responseTime > this.slowRequestThreshold) {\n      const endpoint = this.getEndpointName(req.url);\n      this.toastService.warning(\n        'Requête lente détectée',\n        `${endpoint} a pris ${(responseTime / 1000).toFixed(1)}s à répondre`,\n        { duration: 3000 }\n      );\n    }\n\n    // Succès après retry\n    const attempts = this.retryAttempts.get(requestId) || 0;\n    if (attempts > 0) {\n      this.toastService.success(\n        'Reconnexion réussie',\n        `Requête réussie après ${attempts} tentative${attempts > 1 ? 's' : ''}`,\n        { duration: 2000 }\n      );\n    }\n  }\n\n  /**\n   * Gère les erreurs de requête\n   */\n  private handleError(\n    requestId: string,\n    startTime: number,\n    req: HttpRequest<any>,\n    error: HttpErrorResponse\n  ): void {\n    const endTime = Date.now();\n    const responseTime = endTime - startTime;\n    const endpoint = this.getEndpointName(req.url);\n\n    // Enregistrer les métriques d'erreur\n    this.performanceService.recordApiCall(responseTime);\n\n    // Déterminer le type d'erreur et la réponse appropriée\n    let shouldRetry = false;\n    let errorMessage = '';\n    let userMessage = '';\n\n    switch (error.status) {\n      case 0:\n        // Erreur de réseau\n        errorMessage = 'Erreur de connexion réseau';\n        userMessage = 'Vérifiez votre connexion internet';\n        shouldRetry = true;\n        break;\n      \n      case 408:\n      case 504:\n        // Timeout\n        errorMessage = 'Délai d\\'attente dépassé';\n        userMessage = 'Le serveur met trop de temps à répondre';\n        shouldRetry = true;\n        break;\n      \n      case 429:\n        // Too Many Requests\n        errorMessage = 'Trop de requêtes';\n        userMessage = 'Veuillez patienter avant de réessayer';\n        shouldRetry = false;\n        break;\n      \n      case 500:\n      case 502:\n      case 503:\n        // Erreurs serveur\n        errorMessage = 'Erreur serveur';\n        userMessage = 'Le serveur rencontre des difficultés';\n        shouldRetry = true;\n        break;\n      \n      default:\n        errorMessage = `Erreur ${error.status}`;\n        userMessage = error.error?.message || 'Une erreur est survenue';\n        shouldRetry = false;\n    }\n\n    // Gérer les tentatives de retry\n    const currentAttempts = this.retryAttempts.get(requestId) || 0;\n    const maxRetries = this.getMaxRetries(error.status);\n\n    if (shouldRetry && currentAttempts < maxRetries) {\n      // Préparer pour retry\n      this.retryAttempts.set(requestId, currentAttempts + 1);\n      \n      this.toastService.info(\n        'Nouvelle tentative...',\n        `Tentative ${currentAttempts + 1}/${maxRetries} pour ${endpoint}`,\n        { duration: 1500 }\n      );\n    } else {\n      // Erreur finale\n      this.toastService.error(\n        errorMessage,\n        `${endpoint}: ${userMessage}`,\n        { \n          duration: 5000,\n          dismissible: true\n        }\n      );\n\n      // Si c'était après plusieurs tentatives\n      if (currentAttempts > 0) {\n        this.toastService.error(\n          'Échec définitif',\n          `Impossible de contacter ${endpoint} après ${currentAttempts + 1} tentatives`,\n          { duration: 8000 }\n        );\n      }\n    }\n  }\n\n  /**\n   * Génère un ID unique pour chaque requête\n   */\n  private generateRequestId(req: HttpRequest<any>): string {\n    return `${req.method}_${req.url.split('?')[0]}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n\n  /**\n   * Extrait le nom de l'endpoint pour l'affichage\n   */\n  private getEndpointName(url: string): string {\n    try {\n      const path = new URL(url).pathname;\n      const segments = path.split('/').filter(Boolean);\n      \n      if (segments.length === 0) return 'API';\n      \n      // Prendre les 2 derniers segments ou le dernier si un seul\n      const relevantSegments = segments.slice(-2);\n      return relevantSegments.join('/');\n    } catch {\n      // Si l'URL n'est pas valide, essayer d'extraire manuellement\n      const pathMatch = url.match(/\\/([^\\/\\?]+(?:\\/[^\\/\\?]+)?)(\\?|$)/);\n      return pathMatch ? pathMatch[1] : 'API';\n    }\n  }\n\n  /**\n   * Détermine le nombre maximum de tentatives selon le type d'erreur\n   */\n  private getMaxRetries(status: number): number {\n    switch (status) {\n      case 0:   // Network error\n      case 408: // Request Timeout\n      case 502: // Bad Gateway\n      case 503: // Service Unavailable\n      case 504: // Gateway Timeout\n        return 3;\n      \n      case 500: // Internal Server Error\n        return 2;\n      \n      case 429: // Too Many Requests\n        return 1;\n      \n      default:\n        return 0; // Pas de retry pour les autres erreurs\n    }\n  }\n\n  /**\n   * Vérifie si une requête devrait être retentée\n   */\n  private shouldRetryRequest(error: HttpErrorResponse): boolean {\n    // Liste des codes d'état qui justifient un retry\n    const retryableStatuses = [0, 408, 429, 500, 502, 503, 504];\n    return retryableStatuses.includes(error.status);\n  }\n\n  /**\n   * Calcule le délai d'attente avant retry (backoff exponentiel)\n   */\n  private getRetryDelay(attempt: number): number {\n    // Backoff exponentiel: 1s, 2s, 4s, 8s...\n    return Math.min(1000 * Math.pow(2, attempt), 10000);\n  }\n}"